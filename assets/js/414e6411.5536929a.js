"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[45],{4184:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/build-logging-platform-with-native-kibana-and-clickhouse","metadata":{"permalink":"/ckibana-docs/en/blog/build-logging-platform-with-native-kibana-and-clickhouse","source":"@site/blog/en/build-logging-platform-with-native-kibana-and-clickhouse.md","title":"How to Build a Logging Platform using Native Kibana and ClickHouse","description":"How to Build a Logging Platform using Native Kibana and ClickHouse","date":"2024-08-27T02:54:50.655Z","formattedDate":"August 27, 2024","tags":[{"label":"CKibana","permalink":"/ckibana-docs/en/blog/tags/c-kibana"}],"readingTime":10.295,"truncated":true,"authors":[{"name":"CKibana-Team"}]},"content":"> This article will introduce how to build a logging platform based on native Kibana and Clickhouse.\\n\\n\x3c!--truncate--\x3e\\nIn the rapid development of business, the demand for querying and analyzing various log data leads to a sharp increase in the scale of log storage. Traditional ELK and log systems centered around ElasticSearch subsequently face many challenges in terms of cost, stability, and performance. More and more companies at home and abroad, such as Ctrip, Kuaishou, Bilibili, Cloudflare, and Uber, have been seen switching their storage to ClickHouse, with obvious benefits from their shares. Our log system has also begun to try migrating from ElasticSearch to ClickHouse, exploring and accumulating a set of comprehensive solutions that maximally cater to the existing users\' habits to achieve a smooth transition.\\n\\n## 1  Background Introduction\\n\\nSince the transition from ElasticSearch to Clickhouse in 2020, our company\'s largest log system has seen significant improvements in both cost and stability. It reliably supported over 500 billion logs per day during this year\'s National Day period, with costs reduced to just 30% of the original ElasticSearch solution.\\n\\nBesides this log system, there are many other logging systems within the company, most of which are based on the open-source ELK approach. As scales have increased, issues with costs and stability have gradually emerged, prompting plans to switch all logging system storage foundations to Clickhouse.\\n\\nThe industry has widely shared the selection and usage of Clickhouse for logging scenarios, which will not be the focus of this article. Those interested can search for relevant information on their own.\\n\\nAfter completing the storage switch, the most crucial issue to address is the query UI user experience. While some companies have developed their own query UIs after switching log storage to Clickhouse, accommodating users\' existing habits for a seamless transition from native Kibana to a new platform is challenging. It requires all business colleagues to familiarize themselves with a new set of syntax and UI interactions, inadvertently adding significant costs.\\n\\nTherefore, making it possible for users to migrate to new platform without any learning cost is a rather challenging issue.\\n\\n## 2 Solution Introduction\\n\\nOur approach is actually quite simple and intuitive. We chose to add an additional proxy layer between native Kibana and Elasticsearch. This proxy is responsible for the syntax translation between Elasticsearch and ClickHouse:\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana02.png)\\n\\nWe developed our own Proxy (named CKibana), which translates chart requests into ClickHouse syntax, fetches results from ClickHouse, and then simulates an Elasticsearch response to return to Kibana. This allows us to directly display data from ClickHouse in the native Kibana interface. In addition to the syntax conversion, we also addressed many practical issues encountered during use.\\n\\nConsidering the limitations of ClickHouse\'s query concurrency capabilities, we retained Elasticsearch. This Elasticsearch can be used for advanced features such as result caching and storing metadata related to Kibana, and it is very lightweight.\\n\\n## 3 How to Use CKibana\\n\\n### Components\\n\\n1. Kibana: Used to provide a UI display for business purposes.\\n2. ElasticSearch: Used for storing Kibana metadata and for query caching among other advanced features.\\n3. ClickHouse: The storage system where the actual log data is stored.\\n4. CKibana: Provides Proxy and other advanced functionalities, enabling users to query ClickHouse data directly on the native Kibana.\\n\\n### Getting Started\\n\\n#### Launching CKibana\\n\\nTo start using CKibana, you\'ll first need to configure it with the necessary Elasticsearch details.\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana03.png)\\n\\nOnce you have your configuration set up, ensure that you have JDK 17 or higher installed on your system for CKibana to run. You can then launch CKibana with the following command:\\n\\n`java -jar ckibana.jar`\\n\\n#### Kibana Configuration\\n\\nTo modify the Kibana configuration, change the Elasticsearch address to the CKibana address\uff1a\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana04.png)\\n\\nAt this point, Kibana is fully functional and can use CKibana as an Elasticsearch Proxy\uff1a\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana05.png)\\n\\n#### Configuring ClickHouse Connection Information and Index Whitelist\\n\\nSet up the ClickHouse connection:\\n\\n`curl --location --request POST \'localhost:8080/config/updateCk?url=ckUrl&user=default&pass=default&defaultCkDatabase=ops\'`\\n\\n#### Configure the index to switch to ClickHouse\\n\\n`curl --location --request POST \'localhost:8080/config/updateWhiteIndexList?list=index1,index2\'`\\n\\nThe corresponding relationship between field types in ElasticSearch and ClickHouse is as follows:\\n\\n| es     | ck    |\\n|----------|---------|\\n| keyword  | String  |\\n| text     | String  |\\n| ip       | String(support ipv4 and ipv6)  |\\n| integer  | Int32  |\\n| long     | Int64   |\\n| float    | Float32 |\\n| double   | Float64 |\\n\\n#### Create index pattern\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana06.png)\\n\\nKey Points to Note:\\n\\n1. First, ensure that the input index pattern matches the ClickHouse table exactly; the index pattern and the ClickHouse table name must be an exact match.\\n2. If the corresponding table cannot be selected, you can troubleshoot based on the SQL in the CKibana logs to see if the corresponding table can be queried.\\n3. Pay attention to the time field; otherwise, the time field will not be selectable. The selection logic is as follows:\\n - Fields of the Date type, such as DateTime64, will be considered as time types.\\n - Field names containing \\"time\\", for example (@timestamp UInt64), will be considered as time types.\\n\\nIn either of these two cases, if any one condition is met, the field will be considered a time field. If you are unable to select a time field, it\'s necessary to check whether the fields in the ClickHouse table comply with the matching logic.\\n\\n#### Here we go\\n\\nAfter configuring the index pattern, you can now make full use of Kibana\'s visual analysis capabilities![Untitled](https://oss.17usoft.com/infra-github/ckibana07.png)\\n\\n### Advanced Features\\n\\n#### Sampling\\n\\nMost of Kibana\'s charts focus on trends. When the result set is too large, it consumes more ClickHouse resources. We provide a sampling feature that ensures the chart trends are close to actual trends while effectively controlling the use of ClickHouse resources, especially when dealing with large datasets.\\n\\nNote:\\n- The corresponding ClickHouse table needs to be created according to the ck sampling table requirements.[clickhouse sample](https://clickhouse.com/docs/en/sql-reference/statements/select/sample)\\n- If the sampling threshold is set too low, it can result in a significant difference between the reconstructed values and the true values. We have set our online sampling threshold to 5 million.\\n\\nEnabling sampling requires two steps:\\n1. Configure the tables to be sampled.\\n2. Update the sampling threshold. Sampling is triggered when the result set exceeds this threshold.\\n\\n\\nSampling logic: `Math.max(0.01, Double.parseDouble(String.format(\\"%.5f\\", sampleParam.getSampleCountMaxThreshold() * 1.00 / sampleParam.getSampleTotalCount())))`\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana08.png)\\n\\nExpanding the response from the rate limiter, you can see the sampling value.\\n\\n#### Time Rounding + Caching\\n\\nWhen an issue occurs online, a large number of SRE and business colleagues need to query the nginx logs for troubleshooting, and their query conditions are mostly the same. However, ClickHouse aims to achieve the best query performance by utilizing as many CPUs as possible for computations. This situation leads to ClickHouse\'s CPU usage spiking to full capacity. Moreover, under continuous retries by colleagues, the CPU cannot recover.\\n\\nTherefore, we implemented a feature for time rounding + caching.\\n\\nTime Rounding: For instance, setting rounding to 20s means that the second\'s precision in the query time conditions will be %20, effectively introducing a maximum delay of 20s for data queries.With time rounding in place, a large number of query conditions become identical. At this point, enabling result caching can significantly alleviate the pressure on ClickHouse.\\n\\nSet up time rounding:\\n`curl --location --request POST \'localhost:8080/config/updateRoundAbleMinPeriod?roundAbleMinPeriod=20000\' \u5355\u4f4dms`\\n\\nEnable caching:\\n`curl --location --request POST \'localhost:8080/config/updateUseCache?useCache=true\'`\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana09.png)\\n\\nWhether the cache is hit can be seen in the response structure.\\n\\n#### Query Monitoring + Blacklisting\\n\\nKibana\'s query syntax is relatively flexible, but some queries can consume substantial resources from ClickHouse. Therefore, we have implemented monitoring for all queries and their execution times. This allows us to easily view which queries have been performed and set up blacklisting controls for them. By doing this, we can restrict queries that are not very efficient.\\n\\n\\nEnable monitoring:\\n\\n`curl --location --request POST \'localhost:8080/config/updateEnableMonitoring?enableMonitoring=true\'`\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana10.png)\\n\\nAs shown in the figure above, we can monitor the details, syntax, and execution time of each query.\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana11.png)\\n\\nThis allows us to leverage Kibana\'s powerful built-in chart features for more intuitive analysis.\\n\\n#### Query TimeRange Limits\\n\\nOften, when users want to view the latest trends based on certain conditions, they might directly query data for recent periods, such as the last 7 days. This can lead to significant resource consumption. To manage this, CKibana has implemented a maximum time range for queries, which helps in limiting usage and conserving resources.\\n\\n`curl --location --request POST \'localhost:8080/config/updateMaxTimeRange?maxTimeRange=864000000\' \u5355\u4f4dms`\\n\\n#### keyword Query\\n\\nTo better align with ElasticSearch usage conventions, a `field.keyword` query is equivalent to an exact search on the field, whereas without .keyword it implies a fuzzy search.\\n\\nFor example, `host.keyword:\\"www.baidu.com\\"` when translated into SQL becomes:`host=\\"www.baidu.com\\"`.\\n\\n#### Discover Performance Optimization\\n\\nClickHouse is highly suitable for analytical processing (AP) scenarios, particularly when large time spans are involved in queries. Traditional SQL commands like `select x from table where x order by time desc limit 10` can lead to very low query performance and consume a significant amount of ClickHouse resources.\\n\\nTo address scenarios that involve trend graphs plus details, we have optimized performance to fully leverage ClickHouse\'s AP capabilities. This optimization involves splitting the execution into two steps:\\n1. Leveraging ClickHouse\'s aggregation capabilities to query the number of logs that meet the criteria per minute.\\n2. Based on the number of logs per minute, automatically trimming the log search time span. For instance, if the number of logs within a minute fulfills the requirement, then the query detail time span is automatically reduced to one minute.\\n\\nThis feature of automatically trimming the query time leads to a significant improvement in the query performance of the Discover version and greatly optimizes CPU usage in ClickHouse.\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana15.png)\\n\\nAs illustrated above, a Discover query is divided into three SQL statements:\\n1. Determine whether sampling is needed\\n2. Count the number of logs per minute\\n3. Automatically trim the query time range\\n\\n## 4 Usage scenarios: Nginx logs\\n\\n#### Clickhouse Table\\n\\n``` CREATE TABLE bjops.ops_bjtlblog_local\\n(\\n`@timestamp` UInt64,\\n`X-Request-Id` String,\\n`addr` String,\\n`ap_area` String,\\n`byte` Int64,\\n`bytes_recv` Int64,\\n`Bbtes_sent` Int64,\\n`content-type` String,\\n`content_length` Int64,\\n`crp` String,\\n`csi` String,\\n`cspanid` String,\\n`difftime` Int32,\\n`error_body` String,\\n`error_client` String,\\n`error_host` String,\\n`error_request` String,\\n`error_server` String,\\n`error_upstream` String,\\n`forwarded` String,\\n`host` String,\\n`hostname` String,\\n`idc` LowCardinality(String),\\n`index_name` LowCardinality(String),\\n`ip` String,\\n`logant_idc` LowCardinality(String),\\n`logant_type` LowCardinality(String),\\n`origin_ip` String,\\n`referer` String,\\n`remote_port` String,\\n`request_method` LowCardinality(String),\\n`request_time` Int64,\\n`request_uri` String,\\n`request_url` String,\\n`scheme` String,\\n`server_addr` String,\\n`server_name` String,\\n`server_port` String,\\n`server_protocol` String,\\n`source` String,\\n`sspanid` String,\\n`st` String,\\n`status` Int32,\\n`timeuse` Float64,\\n`traceid` String,\\n`type` String,\\n`ua` String,\\n`up_addr` String,\\n`up_status` Int32,\\n`upstream_name` String,\\n`upstream_response_time` Int32,\\n`worker_pid` String,\\n`ck_assembly_extension` String,\\n`bytes_sent` Int64,\\nINDEX timestamp_index `@timestamp` TYPE minmax GRANULARITY 8192\\n)\\nENGINE = MergeTree\\nPARTITION BY (toYYYYMMDD(toDateTime(`@timestamp` / 1000, \'Asia/Shanghai\')), toHour(toDateTime(`@timestamp` / 1000, \'Asia/Shanghai\')))\\nORDER BY (host, request_uri, intHash64(`@timestamp`))\\nSAMPLE BY intHash64(`@timestamp`)\\nSETTINGS in_memory_parts_enable_wal = 0, index_granularity = 8192\\n```\\n\\nAlways place `host` at the first position in the ORDER BY clause, as most Nginx log queries require sorting based on the `host`.\\n\\n#### CKibana Configuration\\n```\\n{\\n\\t\\"Proxy\\": {\\n\\t\\t\\"ck\\": {\\n\\t\\t\\t\\"url\\": \\"ip:6321\\",\\n\\t\\t\\t\\"user\\": \\"user\\",\\n\\t\\t\\t\\"pass\\": \\"pass\\",\\n\\t\\t\\t\\"defaultCkDatabase\\": \\"db\\"\\n\\t\\t},\\n\\t\\t\\"es\\": {\\n\\t\\t\\t\\"host\\": \\"ip:31940\\"\\n\\t\\t},\\n\\t\\t\\"roundAbleMinPeriod\\": 120000,\\n\\t\\t\\"round\\": 20000,\\n\\t\\t\\"maxTimeRange\\": 86400000,\\n\\t\\t\\"blackIndexList\\": null,\\n\\t\\t\\"whiteIndexList\\": [\\"ops_bjtlblog_all\\", \\"other_index_all\\"],\\n\\t\\t\\"enableMonitoring\\": true\\n\\t},\\n\\t\\"query\\": {\\n\\t\\t\\"sampleIndexPatterns\\": [\\"ops_bjtlblog_all\\"],\\n\\t\\t\\"sampleCountMaxThreshold\\": 5000000,\\n\\t\\t\\"useCache\\": true,\\n\\t\\t\\"maxResultRow\\": 30000\\n\\t},\\n\\t\\"threadPool\\": {\\n\\t\\t\\"msearchProperty\\": {\\n\\t\\t\\t\\"coreSize\\": 4,\\n\\t\\t\\t\\"queueSize\\": 10000\\n\\t\\t},\\n\\t\\t\\"commonProperty\\": {\\n\\t\\t\\t\\"coreSize\\": 4,\\n\\t\\t\\t\\"queueSize\\": 10000\\n\\t\\t}\\n\\t},\\n\\t\\"defaultShard\\": 2\\n}\\n```\\n\\n#### Use Cases\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana12.png)\\n\\n![Untitled](https://oss.17usoft.com/infra-github/ckibana13.png)\\n\\n## 4 Benefits\\n\\nAs of now, by leveraging CKibana\'s core capabilities, we have successfully completed the full migration of all Nginx access logs and business-customized logs from Elasticsearch to Clickhouse, reducing our storage costs to below 30% of the original. Moreover, thanks to ClickHouse\'s distributed table capabilities, log queries remain unaffected even in the event of a single center failure, offering significant improvements over Elasticsearch in both cost and stability. We have also continued to use the flexible and powerful native Kibana as our visualization tool, allowing users to conveniently perform log queries and analyses using their familiar Kibana dashboard.\\n\\n## 5 Finally\\n\\nOur logging system\'s continuous evolution owes much to numerous outstanding open-source projects. Having proven stable and reliable internally, we\'re now excited to open-source the CKibana project. We also look forward to collaborating with the community to continuously enhance its functionality, fully leveraging the Kibana visualization and ClickHouse storage combination for log analysis.\\n\\nGithub Repo: https://github.com/TongchengOpenSource/ckibana/\\n\\nWe hope you find it useful and welcome your feedback. Thanks~"}]}')}}]);